<!DOCTYPE html>
<html>
  <head><meta name="generator" content="Hexo 3.9.0">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="description" content="Back-End 기술에 대한 이야기를 나누는 블로그">
  <meta name="keyword" content="Java, Spring">
  
    <link rel="shortcut icon" href="/css/images/logo.png">
  
  <title>
    
      Network - 캐시 | Junjangsee&#39;s Blog
    
  </title>
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.css" rel="stylesheet">
  <link href="//cdn.bootcss.com/highlight.js/9.12.0/styles/tomorrow.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/style.css">
  
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  <script src="//cdn.bootcss.com/geopattern/1.2.3/js/geopattern.min.js"></script>
  <script src="//cdn.bootcss.com/nprogress/0.2.0/nprogress.min.js"></script>
</head>
<div class="wechat-share">
  <img src="/css/images/logo.png">
</div>

  <body>
    <header class="header fixed-header">
  <div class="header-container">
    <a class="home-link" href="/">
      <div class="logo"></div>
      <span>Junjangsee's Blog</span>
    </a>
    <ul class="right-list">
      
        <li class="list-item">
          
            <a href="/" class="item-link">Home</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/tags/" class="item-link">Tags</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/project/" class="item-link">Projects</a>
          
        </li>
      
        <li class="list-item">
          
            <a href="/about/" class="item-link">About</a>
          
        </li>
      
    </ul>
    <div class="menu">
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </div>
    <div class="menu-mask">
      <ul class="menu-list">
        
          <li class="menu-item">
            
              <a href="/" class="menu-link">Home</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/tags/" class="menu-link">Tags</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/project/" class="menu-link">Projects</a>
            
          </li>
        
          <li class="menu-item">
            
              <a href="/about/" class="menu-link">About</a>
            
          </li>
        
      </ul>
    </div>
  </div>
</header>

    <div id="article-banner">
  <h2>Network - 캐시</h2>
  <p class="post-date">2019-09-29</p>
  <div class="arrow-down">
    <a href="javascript:;"></a>
  </div>
</div>
<main class="app-body flex-box">
  <!-- Article START -->
  <article class="post-article">
    <section class="markdown-content"><p><img src="/images/network/network.jpg" alt="images"><br></p>
<p><strong>이번 장에서 살펴볼 주제</strong></p>
<ul>
<li>캐시는 불필요한 데이터 전송을 줄여서, 네트워크 요금으로 인한 비용을 줄여준다.</li>
<li>캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 된다.</li>
<li>캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.</li>
<li>페이지를 먼 곳에서 불러올수록 시간이 많이 걸리는데 캐시는 거리로 인한 지연을 줄여준다.</li>
</ul>
<p><br></p>
<h1 id="불필요한-데이터-전송"><a href="#불필요한-데이터-전송" class="headerlink" title="불필요한 데이터 전송"></a>불필요한 데이터 전송</h1><p>복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할 때, 서버는 같은 문서를 각각 한 번씩 전송하게 됩니다. 이 떄 똑같은 바이트들이 네트워크를 통해 반복해서 이동하는데 이 불필요한 데이터 전송은 <code>웹 서버</code>에 <strong>부하</strong>를 줍니다. 이 때 캐시를 이용하면, 서버 응답은 <code>캐시</code>에 보관되며 캐시된 사본이 뒤이은 요청들에 대한 응답으로 사용되기 때문에 낭비가 줄어듭니다.<br><br><br></p>
<h1 id="대역폭-방목"><a href="#대역폭-방목" class="headerlink" title="대역폭 방목"></a>대역폭 방목</h1><p>캐시는 네트워크 병목을 줄여줍니다. <strong>클라이언트</strong>들이 서버에 접근할 때의 속도는, 그 경로에 있는 <strong>가장 느린</strong> 네트워크의 속도와 같습니다. 이 때 만약 <strong>클라이언트</strong>가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면 성능이 대폭 향상될 것입니다.<br><br><br></p>
<h1 id="갑작스런-요청-쇄도"><a href="#갑작스런-요청-쇄도" class="headerlink" title="갑작스런 요청 쇄도"></a>갑작스런 요청 쇄도</h1><p>캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요합니다. 많은 사람들이 동시에 웹 문서에 접근할 때 이런 일이 발생합니다. 이 상황을 막기 위해 캐시를 이용합니다.<br><br><br></p>
<h1 id="거리로-인한-지연"><a href="#거리로-인한-지연" class="headerlink" title="거리로 인한 지연"></a>거리로 인한 지연</h1><p>대역폭이 문제가 되지 않는 상황이라면, 거리가 문제가 될 수도 있습니다. 기계실 근처에 캐시를 설치해서 문서가 전송되는 거리를 줄이는 방법이 있습니다.<br><br><br></p>
<h1 id="적중과-부적중"><a href="#적중과-부적중" class="headerlink" title="적중과 부적중"></a>적중과 부적중</h1><p>캐시가 세상 모든 문서의 사본을 저장하지는 않는데, 캐시에 요청이 들어왔을 때 해당하는 사본이 있다면 요청이 처리되어 <code>캐시 적중</code>이 되고 만약 해당되는 사본이 없다면 그냥 우너 서버로 전달되는 <code>캐시 부적중</code>이 발생합니다.<br></p>
<h2 id="재검사"><a href="#재검사" class="headerlink" title="재검사"></a>재검사</h2><p>원 서버 컨텐츠는 변경될 수 있기 떄문에, 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 점검해야합니다. 이를 <code>재검사</code>라고 합니다. 대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 검사를 할 필요가 있을 정도로 오래된 경우에만 재검사를 합니다. 이 때 사본이 여전히 유효하면 서버에 <code>304 Not Modified</code> 응답을 보내고 클라이언트에게 제공합니다. HTTP는 캐시된 객체를 재확인 하기 위해 몇 가지 <strong>도구</strong>를 제공하는데 그 중에서 가장 많이 쓰이는 것은 <code>If-Modified-Since</code> 헤더입니다.<br><br>서버에게 보내는 GET 요청이 이 헤더를 추가하면 캐시된 시간 이후에 <strong>변경된 경우</strong>에만 사본을 보내달라는 의미가 됩니다. 아래는 GET If-Modified-Since 요청이 서버에 도착했을 때 일어나는 세 가지 상황에 대해서 알아보겠습니다.</p>
<ul>
<li>재검사 적중 : 만약 서버 객체가 변경되지 않았다면, 서버는 클라이언트에게 304 Not Modified를 보냅니다.</li>
<li>재검사 부적중 : 만약 서버 객체가 캐시된 사본과 다르다면은 서버는 컨텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보냅니다.</li>
<li>객체 삭제 : 만약 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 돌려보내며 캐시는 사본을 삭제합니다.<br><br><br></li>
</ul>
<h2 id="적중률"><a href="#적중률" class="headerlink" title="적중률"></a>적중률</h2><p>캐시가 <strong>요청을 처리하는 비율</strong>을 <code>캐시 적중률</code>, 혹은 <code>문서 적중률</code>이라고 부릅니다. 적중률은 0 ~ 1까지의 값으로 되어있지만, 흔히 퍼센트로 표현되기도 합니다. <strong>0%</strong>는 모든 요청이 캐시 부적중, <strong>100%</strong>는 모든 요청이 캐시 적중임을 의미합니다.<br><br><br></p>
<h2 id="바이트-적중률"><a href="#바이트-적중률" class="headerlink" title="바이트 적중률"></a>바이트 적중률</h2><p>모든 문서가 같은 크기가 아니기 때문에 특정 사람들은 <code>바이트 적중률</code>을 더 선호합니다.<br><br><br></p>
<h2 id="적중과-부적중의-구별"><a href="#적중과-부적중의-구별" class="headerlink" title="적중과 부적중의 구별"></a>적중과 부적중의 구별</h2><p>클라이언트가 응답이 캐시에서 왔는지 알아내는 한 가지 방법은 <code>Date 헤더</code>를 이용하는 것입니다. 응답의 Date 헤더값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있습니다.<br><br><br></p>
<h1 id="캐시-토폴로지"><a href="#캐시-토폴로지" class="headerlink" title="캐시 토폴로지"></a>캐시 토폴로지</h1><p>캐시는 <strong>한 명</strong>의 사용자에게만 할당될 수도 있고 반대로 <strong>수천 명</strong>의 사용자들 간에 공유될 수도 있습니다.<br><br><br></p>
<h2 id="개인-전용-캐시"><a href="#개인-전용-캐시" class="headerlink" title="개인 전용 캐시"></a>개인 전용 캐시</h2><p><code>개인 전용 캐시</code>는 많은 에너지나 저장 공간을 필요로 하지 않으므로, <strong>작고 저렴</strong>할 수 있습니다. 웹 브라우저는 개인 전용 캐시를 내장하고 있으며 대부분의 브라우저는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크나 메모리에 캐시해 놓고 사용자가 캐시 사이즈 및 설정을 수정할 수 있도록 합니다.<br><br><br></p>
<h2 id="공용-프락시-캐시"><a href="#공용-프락시-캐시" class="headerlink" title="공용 프락시 캐시"></a>공용 프락시 캐시</h2><p>공용 캐시는 캐시 프락시 서버 혹은 더 흔히 <code>프락시 캐시</code>라고 불리는 특별한 종류의 공유된 프락시 서버입니다. 프락시 캐시는 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근합니다. 공용 캐시에는 여러 사용자가 접근하기 때문에, 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있습니다.<br><br><br></p>
<h2 id="프락시-캐시-계층들"><a href="#프락시-캐시-계층들" class="headerlink" title="프락시 캐시 계층들"></a>프락시 캐시 계층들</h2><p>작은 캐시에서 캐시 부적중이 발생했을 때 더 큰 부모 캐시가 그 ‘걸러 남겨진’ 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적입니다.<br><br><br></p>
<h2 id="캐시망-컨텐츠-라우팅-피어링"><a href="#캐시망-컨텐츠-라우팅-피어링" class="headerlink" title="캐시망, 컨텐츠 라우팅, 피어링"></a>캐시망, 컨텐츠 라우팅, 피어링</h2><p>몇몇 네트워크 아키텍쳐는 단순한 캐시 계층 대신 복잡한 캐시망을 만들고 복잡한 방식으로 서로 대화하여 서로간의 커뮤니케이션 결정을 동적으로 내립니다. 이러한 한층 더 복잡한 캐시 사이의 관계는, 서로 다른 조직들이 상호 이득을 위해 그들의 캐시를 연결하여 서로를 찾아볼 수 있도록 해줍니다.<br><br><br></p>
<h2 id="캐시-처리-단계"><a href="#캐시-처리-단계" class="headerlink" title="캐시 처리 단계"></a>캐시 처리 단계</h2><p>웹 캐시는 <strong>7단계</strong>로 이루어져 있습니다.</p>
<ol>
<li>요청 받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽습니다.</li>
<li>파싱 - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출합니다.</li>
<li>검색 - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아옵니다.</li>
<li>신선도 검사 - 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어봅니다.</li>
<li>응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만듭니다.</li>
<li>발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려줍니다.</li>
<li>로깅 - ㅅ너택적으로, 캐시는 로그파일에 트랜잭션에 대해 서술한 로그 하나를 남깁니다.</li>
</ol>
<p><br></p>
<h2 id="사본을-신선하게-유지하기"><a href="#사본을-신선하게-유지하기" class="headerlink" title="사본을 신선하게 유지하기"></a>사본을 신선하게 유지하기</h2><p>캐시된 사본 모두가 서버의 문서와 항상 일치하는 것은 아닙니다. HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘을 가지고 있습니다. 이를 <code>서버 재검사</code>라고 부릅니다.<br></p>
<h3 id="문서-만료"><a href="#문서-만료" class="headerlink" title="문서 만료"></a>문서 만료</h3><p>HTTP는 <code>Cache-Control</code>과 <code>Expires</code>라는 특별한 헤더들을 이용해서 원 서버가 각 문서에 <strong>유효기간</strong>을 붙일 수 있게 해줍니다. 이 헤더들은 컨텐츠가 얼마나 오랫동안 신선한 상태로 보일 수 있는지 좌우합니다. 캐시된 문서가 만료되면 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야하며, 만약 그렇다면 신선한 사본을 얻어 와야 합니다.<br><br><br></p>
<h3 id="유효기간과-나이"><a href="#유효기간과-나이" class="headerlink" title="유효기간과 나이"></a>유효기간과 나이</h3><p><code>Cache-Control : max-age</code>과 <code>Expires</code>헤더는 기본적으로 <strong>같은 일</strong>을 하지만, 절대 시간은 컴퓨터의 <strong>시계</strong>가 올바르게 맞추어져 있을 것을 요구합니다.<br><br><br></p>
<h3 id="서버-재검사"><a href="#서버-재검사" class="headerlink" title="서버 재검사"></a>서버 재검사</h3><p>캐시된 문서가 만료되었는다는 것은, 그 문서가 우너 서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지 않으나 다만 이제 검사할 시간이 되었다는 것을 뜻합니다. 이 문서가 변경되었는지의 여부를 물어보는 것을 의미하는 것이 <code>서버 재검사</code>라고 합니다.</p>
<ul>
<li>재검사 결과 컨텐츠가 변경되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내줍니다.</li>
<li>재검사 결과 컨텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신합니다.</li>
</ul>
<p><br></p>
<h3 id="조건부-메소드와의-재검사"><a href="#조건부-메소드와의-재검사" class="headerlink" title="조건부 메소드와의 재검사"></a>조건부 메소드와의 재검사</h3><p>HTTP의 <code>조건부 메소드</code>는 재검사를 효율적으로 만들어줍니다. HTTP는 캐시가 서버에게 <code>조건부 GET</code>이라는 요청을 보낼 수 있도록 해줍니다. 이 요청은 서버가 가지고 있는 문서가 캐시가 가지고 있는 것과 <strong>다른</strong> 경우에만 객체 본문을 보내달라고 하는 것입니다. 캐시 재검사를 할 때 가장 유용한 <strong>If-Modified-Since</strong>, <strong>If-None-Match</strong>에 대해서 살펴보겠습니다.<br><br><br></p>
<h3 id="If-Modified-Since-날짜-재검사"><a href="#If-Modified-Since-날짜-재검사" class="headerlink" title="If-Modified-Since : 날짜 재검사"></a>If-Modified-Since : 날짜 재검사</h3><p>가장 흔히 싸용되며 흔히 <strong>IMS</strong>라고 불립니다. IMS 요청은 서버에게 리소스가 <strong>특정 날짜 이후</strong>로 변경된 경우에만 요청한 본문을 보내달라고 합니다. 몇몇 웹 서버는 실제 날짜 비교로 구현하지 않지만, IMS 날짜와 최근 변경일 간의 문자열 비교를 수행합니다.<br><br><br></p>
<h3 id="If-None-Match-엔티티-태그-재검사"><a href="#If-None-Match-엔티티-태그-재검사" class="headerlink" title="If-None-Match : 엔티티 태그 재검사"></a>If-None-Match : 엔티티 태그 재검사</h3><p>퍼블리셔 등 누군가가 문서를 변경했을 때, 문서의 엔티티 태그를 새로운 버전으로 표현할 수 있습니다. 엔티티 태그가 변경되었다면, 캐시는 새 문서의 사본을 얻기 위해 <code>If-None-Match</code> 조건부 헤더를 사용할 수 있습니다.<br><br><br></p>
<h3 id="약한-검사기와-강한-검사기"><a href="#약한-검사기와-강한-검사기" class="headerlink" title="약한 검사기와 강한 검사기"></a>약한 검사기와 강한 검사기</h3><p>캐시는 캐시된 버전이 서버가 갖고 있는 걳에 대해 최신인지 확인하기 위해 엔티티 태그를 사용합니다. 이 경우엔 <strong>엔티티 태그</strong>와 <strong>최근 변경일시</strong>는 둘 다 캐시 검사기입니다.<br><code>강한 엔티티 태그</code>는 대응하는 엔티티 값이 어떻게 바뀌든 매번 반드시 같이 바뀌어야 합니다. <code>약한 엔티티 태그</code>는 대응하는 엔티티에 유의미한 변경이 있을 때마다 같이 변경되어야 합니다. 원 서버는 서로 다른 두 엔티티에 대해 강한 엔티티 태그 값을 재활용 해서는 안되며, 약한 엔티티 태그 값이라고 해도 재활용해선 안됩니다.<br><br><br></p>
<h3 id="언제-엔티티-태그를-사용하고-언제-Last-Modified-일시를-사용하는가"><a href="#언제-엔티티-태그를-사용하고-언제-Last-Modified-일시를-사용하는가" class="headerlink" title="언제 엔티티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가"></a>언제 엔티티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가</h3><p>HTTP/1.1 클라이언트는 만약 서버가 엔티티 태그를 반환했다면, <strong>반드시</strong> 엔티티 태그 검사기를 이용해야 합니다. 만약 서버가 <strong>Last-Modified</strong> 값만을 반환했다면, 클라이언트는 <strong>If-Modified-Since</strong> 검사를 사용할 수 있습니다. HTTP/1.1 캐시나 서버가 If-Modified-Since와 엔티티 태그 조건부 헤더를 <strong>모두</strong> 받았다면, 요청의 모든 조건부 헤더 필드의 조건에 부합되지 않는 한 <strong>304 Not Modified</strong> 응답을 반환해서는 안됩니다.<br><br><br></p>
<h2 id="캐시-제어"><a href="#캐시-제어" class="headerlink" title="캐시 제어"></a>캐시 제어</h2><p>HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러 가지 방법을 정의합니다.<br></p>
<h3 id="no-cache와-no-store-응답-헤더"><a href="#no-cache와-no-store-응답-헤더" class="headerlink" title="no-cache와 no-store 응답 헤더"></a>no-cache와 no-store 응답 헤더</h3><p>HTTP/1.1은 신선도를 관리하기 위해, 객체를 캐시하는 것을 제한하거나 캐시된 객체를 제공하는 여러가지 방법을 제공합니다.</p>
<ul>
<li>no-store : 캐시가 그 응답의 사본을 만드는 것을 금지합니다.</li>
<li>no-cache : 로컬 캐시 저장소에 저장될 수도 있지만 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없습니다.</li>
</ul>
<p><br></p>
<h3 id="Max-Age-응답-헤더"><a href="#Max-Age-응답-헤더" class="headerlink" title="Max-Age 응답 헤더"></a>Max-Age 응답 헤더</h3><p><code>Cache-Control : Max-age</code> 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타냅니다.<br><br><br></p>
<h3 id="Expires-응답-헤더"><a href="#Expires-응답-헤더" class="headerlink" title="Expires 응답 헤더"></a>Expires 응답 헤더</h3><p>더 이상 사용하지 않기를 권하는 <code>Expires 헤더</code>는 초 단위의 시간 대신 실제 만료 날짜를 명시합니다.<br><br><br></p>
<h3 id="Must-Revalidate-응답-헤더"><a href="#Must-Revalidate-응답-헤더" class="headerlink" title="Must-Revalidate 응답 헤더"></a>Must-Revalidate 응답 헤더</h3><p>캐시는 <strong>성능을 개선</strong>하기 위해 신선하지 않은 객체를 제공하도록 설정할 수 있습니다. <code>Cache-Control : Must-revalidate</code> 응답 헤더는 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안 됨을 의미합니다.<br><br><br></p>
<h3 id="휴리스틱-만료"><a href="#휴리스틱-만료" class="headerlink" title="휴리스틱 만료"></a>휴리스틱 만료</h3><p>만약 응답이 Cache-Control : Max-age 헤더나 Expires 헤더 중 어느 것도 포함하지 않고 있다면, 캐시는 경험적인 방법으로 최대 나이를 계산할 것입니다. 유명 휴리스틱 만료 알고리즘인 <strong>LM</strong> 인자 알고리즘은 최근 변경 일시를 문서가 얼마나 자주 바뀌는지 추정합니다.<br><br><br></p>
<h3 id="클라이언트-신선도-제약"><a href="#클라이언트-신선도-제약" class="headerlink" title="클라이언트 신선도 제약"></a>클라이언트 신선도 제약</h3><p>웹 브라우저는 브라우저나 프락시 캐시의 신선하지 않은 컨텐츠를 강제로 갱신시켜주는 <strong>리프레시</strong>나 <strong>리로드 버튼</strong>을 가지고 있습니다. 이 <strong>리프레시 버튼</strong>은 Cache-control 요청 헤더가 추가된 GET 요청을 발생시켜서, 강제로 재검사하거나 서버로부터 컨텐츠를 무조건 가져옵니다. 클라이언트는 Cache-Control 요청 헤더를 사용하여 만료 제약을 <strong>엄격</strong>하게 하거나 <strong>느슨</strong>하게 할 수 있습니다.<br><br><br></p>
<h3 id="주의할-점"><a href="#주의할-점" class="headerlink" title="주의할 점"></a>주의할 점</h3><p>문서 만료는 완벽한 시스템이 아닙니다. 만약 퍼블리셔가 잘못해서 유효기간을 아주 먼 미래로 잡는다면 만료되기 전까지는 그 문서에 대한 변경사항이 캐시에 반영되지 않을 것입니다. 또한 아예 유효기간을 사용하지 않아서 신선도를 알기 어렵게 될 수도 있습니다.<br><br><br></p>
<h2 id="캐시-제어-설정"><a href="#캐시-제어-설정" class="headerlink" title="캐시 제어 설정"></a>캐시 제어 설정</h2><p>아파치 웹 서버가 캐시 제어를 어떻게 지원하는지 알아보겠습니다.<br></p>
<h3 id="아파치로-HTTP-헤더-제어하기"><a href="#아파치로-HTTP-헤더-제어하기" class="headerlink" title="아파치로 HTTP 헤더 제어하기"></a>아파치로 HTTP 헤더 제어하기</h3><p>아파치의 웹 서버는 여러가지 메커니즘을 제공하지만 대부분 디폴트로 가능하지 않아서 활성화 시킬 필요가 있습니다.</p>
<ul>
<li>mod_headers : 개별 헤더들을 설정할 수 있게 해줍니다. </li>
<li>mod_expires : 적절한 만료 날짜가 담긴 Expires 헤더를 자동으로 생성하는 프로그램 로직을 제공합니다.</li>
<li>mod_cern_meta : HTTP 헤더들의 파일을 특정 객체와 연결시켜줍니다.</li>
</ul>
<p><br></p>
<h3 id="HTTP-EQUIV를-통한-HTML-캐시-제어"><a href="#HTTP-EQUIV를-통한-HTML-캐시-제어" class="headerlink" title="HTTP-EQUIV를 통한 HTML 캐시 제어"></a>HTTP-EQUIV를 통한 HTML 캐시 제어</h3><p>웹 서버 설정 파일과의 상호작용 없이도 쉽게 HTML 문서에 HTTP 헤더 정보를 부여할 수 있도록 하기 위해, HTML 2.0은 <code>&lt;META HTTP-EQUIV&gt;</code> 태그를 정의했습니다. 이 태그는 HTML 문서의 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의합니다.<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">HEAD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TITLE</span>&gt;</span>My Document<span class="tag">&lt;/<span class="name">TITLE</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">META</span> <span class="attr">HTTP-EQUIV</span>=<span class="string">"Cache-Control"</span> <span class="attr">CONTENT</span>=<span class="string">"no-cache"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">HEAD</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>위와 같이 표현이 가능합니다.</p>
</section>
    <!-- Tags START -->
    
      <div class="tags">
        <span>Tags:</span>
        
  <a href="/tags#HTTP" >
    <span class="tag-code">HTTP</span>
  </a>

  <a href="/tags#캐시" >
    <span class="tag-code">캐시</span>
  </a>

  <a href="/tags#Cache" >
    <span class="tag-code">Cache</span>
  </a>

      </div>
    
    <!-- Tags END -->
    <!-- NAV START -->
    
  <div class="nav-container">
    <!-- reverse left and right to put prev and next in a more logic postition -->
    
      <a class="nav-left" href="/2019/09/29/network/ssl/">
        <span class="nav-arrow">← </span>
        
          AWS Certificate Manager를 이용한 SSL인증서 발급받기
        
      </a>
    
    
      <a class="nav-right" href="/2019/10/13/network/network-08/">
        
          Network - 게이트웨이, 터널, 릴레이
        
        <span class="nav-arrow"> →</span>
      </a>
    
  </div>

    <!-- NAV END -->
    <!-- 打赏 START -->
    
    <!-- 打赏 END -->
    <!-- 二维码 START -->
    
    <!-- 二维码 END -->
    
      <!-- No Comment -->
    
  </article>
  <!-- Article END -->
  <!-- Catalog START -->
  
    <aside class="catalog-container">
  <div class="toc-main">
    <strong class="toc-title">Catalog</strong>
    
      <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#불필요한-데이터-전송"><span class="toc-nav-text">불필요한 데이터 전송</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#대역폭-방목"><span class="toc-nav-text">대역폭 방목</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#갑작스런-요청-쇄도"><span class="toc-nav-text">갑작스런 요청 쇄도</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#거리로-인한-지연"><span class="toc-nav-text">거리로 인한 지연</span></a></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#적중과-부적중"><span class="toc-nav-text">적중과 부적중</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#재검사"><span class="toc-nav-text">재검사</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#적중률"><span class="toc-nav-text">적중률</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#바이트-적중률"><span class="toc-nav-text">바이트 적중률</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#적중과-부적중의-구별"><span class="toc-nav-text">적중과 부적중의 구별</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-1"><a class="toc-nav-link" href="#캐시-토폴로지"><span class="toc-nav-text">캐시 토폴로지</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#개인-전용-캐시"><span class="toc-nav-text">개인 전용 캐시</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#공용-프락시-캐시"><span class="toc-nav-text">공용 프락시 캐시</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#프락시-캐시-계층들"><span class="toc-nav-text">프락시 캐시 계층들</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#캐시망-컨텐츠-라우팅-피어링"><span class="toc-nav-text">캐시망, 컨텐츠 라우팅, 피어링</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#캐시-처리-단계"><span class="toc-nav-text">캐시 처리 단계</span></a></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#사본을-신선하게-유지하기"><span class="toc-nav-text">사본을 신선하게 유지하기</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#문서-만료"><span class="toc-nav-text">문서 만료</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#유효기간과-나이"><span class="toc-nav-text">유효기간과 나이</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#서버-재검사"><span class="toc-nav-text">서버 재검사</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#조건부-메소드와의-재검사"><span class="toc-nav-text">조건부 메소드와의 재검사</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#If-Modified-Since-날짜-재검사"><span class="toc-nav-text">If-Modified-Since : 날짜 재검사</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#If-None-Match-엔티티-태그-재검사"><span class="toc-nav-text">If-None-Match : 엔티티 태그 재검사</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#약한-검사기와-강한-검사기"><span class="toc-nav-text">약한 검사기와 강한 검사기</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#언제-엔티티-태그를-사용하고-언제-Last-Modified-일시를-사용하는가"><span class="toc-nav-text">언제 엔티티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#캐시-제어"><span class="toc-nav-text">캐시 제어</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#no-cache와-no-store-응답-헤더"><span class="toc-nav-text">no-cache와 no-store 응답 헤더</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Max-Age-응답-헤더"><span class="toc-nav-text">Max-Age 응답 헤더</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Expires-응답-헤더"><span class="toc-nav-text">Expires 응답 헤더</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#Must-Revalidate-응답-헤더"><span class="toc-nav-text">Must-Revalidate 응답 헤더</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#휴리스틱-만료"><span class="toc-nav-text">휴리스틱 만료</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#클라이언트-신선도-제약"><span class="toc-nav-text">클라이언트 신선도 제약</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#주의할-점"><span class="toc-nav-text">주의할 점</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-2"><a class="toc-nav-link" href="#캐시-제어-설정"><span class="toc-nav-text">캐시 제어 설정</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#아파치로-HTTP-헤더-제어하기"><span class="toc-nav-text">아파치로 HTTP 헤더 제어하기</span></a></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#HTTP-EQUIV를-통한-HTML-캐시-제어"><span class="toc-nav-text">HTTP-EQUIV를 통한 HTML 캐시 제어</span></a></li></ol></li></ol></li></ol>
    
  </div>
</aside>
  
  <!-- Catalog END -->
</main>

<script>
  (function () {
    var url = 'https://junjangsee.github.io/2019/09/29/network/network-07/';
    var banner = ''
    if (banner !== '' && banner !== 'undefined' && banner !== 'null') {
      $('#article-banner').css({
        'background-image': 'url(' + banner + ')'
      })
    } else {
      $('#article-banner').geopattern(url)
    }
    $('.header').removeClass('fixed-header')

    // error image
    $(".markdown-content img").on('error', function() {
      $(this).attr('src', 'http://file.muyutech.com/error-img.png')
      $(this).css({
        'cursor': 'default'
      })
    })

    // zoom image
    $(".markdown-content img").on('click', function() {
      var src = $(this).attr('src')
      if (src !== 'http://file.muyutech.com/error-img.png') {
        var imageW = $(this).width()
        var imageH = $(this).height()

        var zoom = ($(window).width() * 0.95 / imageW).toFixed(2)
        zoom = zoom < 1 ? 1 : zoom
        zoom = zoom > 2 ? 2 : zoom
        var transY = (($(window).height() - imageH) / 2).toFixed(2)

        $('body').append('<div class="image-view-wrap"><div class="image-view-inner"><img src="'+ src +'" /></div></div>')
        $('.image-view-wrap').addClass('wrap-active')
        $('.image-view-wrap img').css({
          'width': `${imageW}`,
          'transform': `translate3d(0, ${transY}px, 0) scale3d(${zoom}, ${zoom}, 1)`
        })
        $('html').css('overflow', 'hidden')

        $('.image-view-wrap').on('click', function() {
          $(this).remove()
          $('html').attr('style', '')
        })
      }
    })
  })();
</script>







    <div class="scroll-top">
  <span class="arrow-icon"></span>
</div>
    <footer class="app-footer">
  <p class="copyright">
    &copy; 2019 | Proudly powered by <a href="https://hexo.io" target="_blank">Hexo</a>
    <br>
    Theme by <a href="https://github.com/yanm1ng">yanm1ng</a>
  </p>
</footer>

<script>
  function async(u, c) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }
</script>
<script>
  async("//cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
    FastClick.attach(document.body);
  })
</script>

<script>
  var hasLine = 'true';
  async("//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js", function(){
    $('figure pre').each(function(i, block) {
      var figure = $(this).parents('figure');
      if (hasLine === 'false') {
        figure.find('.gutter').hide();
      }
      var lang = figure.attr('class').split(' ')[1] || 'code';
      var codeHtml = $(this).html();
      var codeTag = document.createElement('code');
      codeTag.className = lang;
      codeTag.innerHTML = codeHtml;
      $(this).attr('class', '').empty().html(codeTag);
      figure.attr('data-lang', lang.toUpperCase());
      hljs.highlightBlock(block);
    });
  })
</script>
<!-- Baidu Tongji -->

<script src="/js/script.js"></script>
  </body>
</html>